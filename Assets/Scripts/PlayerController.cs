using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.Events;


using Colosseum;

public class PlayerController : MonoBehaviour
{
    private Animator animator;

    Transform center;

    Vector3 velocity = Vector3.zero;
    Vector3 currentVelocity = Vector3.zero;

    // Ä¿¸Çµå°ü·Ã º¯¼ö
    Queue<int> commands;
    int postCommand = 0;
    // Ä¿¸Çµå ÀÔ·Â
    // Vector2(horizontal, vertical)
    Dictionary<Vector2, Vector3> horiVer = new Dictionary<Vector2, Vector3>()
        {
            {new Vector2(-1, -1), Vector3.zero },
            {new Vector2(-1, 0), Vector3.back },
            {new Vector2(-1, 1), Vector3.zero },

            {new Vector2(0, -1), Vector3.zero },
            {new Vector2(0, 0), Vector3.zero },
            {new Vector2(0, 1), Vector3.zero },

            {new Vector2(1, -1), Vector3.zero },
            {new Vector2(1, 0), Vector3.forward },
            {new Vector2(1, 1), Vector3.zero }
        };
    Dictionary<Vector2, int> horiVerCommand = new Dictionary<Vector2, int>()
        {
            {new Vector2(-1, -1), 1 },
            {new Vector2(-1, 0), 4 },
            {new Vector2(-1, 1), 7 },

            {new Vector2(0, -1), 2 },
            {new Vector2(0, 0), 5 },
            {new Vector2(0, 1), 8 },

            {new Vector2(1, -1), 3 },
            {new Vector2(1, 0), 6 },
            {new Vector2(1, 1), 9 }
        };

    [SerializeField]
    Dictionary<int, AttackArea.AttackInfo> attackInfoDictLP;
    Dictionary<int, AttackArea.AttackInfo> attackInfoDictRP;
    Dictionary<int, AttackArea.AttackInfo> attackInfoDictLK;
    Dictionary<int, AttackArea.AttackInfo> attackInfoDictRK;

    Dictionary<int, CommandPattern.Action> attackInfoCommandLP;
    Dictionary<int, CommandPattern.Action> attackInfoCommandRP;
    Dictionary<int, CommandPattern.Action> attackInfoCommandLK;
    Dictionary<int, CommandPattern.Action> attackInfoCommandRK;

    Status status;
    public AttackArea.AttackInfo attackInfo;
    FightManager fightManager;

    TestStateBehaviour stateBehaviour;

    CommandSystem commandSystem;

    bool isHit;
    Animator opponentAnimator;
    public UnityEvent HitEvent;
    GameObject manager;
    public EffectManager effectManager;

    bool isGuard;

    Coroutine currentCoroutine;
    int currentPriority;

    AttackAreaManager attackAreaManager;

    ReplaySystem replaySystem;

    // Start is called before the first frame update
    void Start()
    {
        animator = gameObject.GetComponent<Animator>();
        center = GameObject.Find("CenterPoint").transform;

        commands = new Queue<int>();

        status = GetComponent<Status>();
        status.CurrentState = State.Standing;

        attackInfo = new AttackArea.AttackInfo();

        fightManager = FindObjectOfType<FightManager>();


        attackInfoDictLP = new Dictionary<int, AttackArea.AttackInfo>()
        {
            // Àì
            {1, new AttackArea.AttackInfo(10, transform, AttackArea.AttackType.upper, Vector3.zero) },
            // ÈÅ
            {2, new AttackArea.AttackInfo(15, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ¾îÆÛ
            {3, new AttackArea.AttackInfo(17, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ÁøÂ¥ Àì
            {4, new AttackArea.AttackInfo(5, transform, AttackArea.AttackType.upper, new Vector3(0,500f,200f)) },
            // ¹éºí·Î¿ì
            {5, new AttackArea.AttackInfo(14, transform, AttackArea.AttackType.upper, Vector3.zero) },
            // ÀüÁø ÈÅ
            {6, new AttackArea.AttackInfo(12, transform, AttackArea.AttackType.upper, Vector3.zero) },
            // ÆÈ²ÞÄ¡ ÇØ¸Ó
            {7, new AttackArea.AttackInfo(19, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // Äü ÈÅ
            {8, new AttackArea.AttackInfo(10, transform, AttackArea.AttackType.upper, Vector3.zero) },
            // ¹Ùµð ºí·Î¿ì
            {9, new AttackArea.AttackInfo(18, transform, AttackArea.AttackType.middle, Vector3.zero) }

        };
        attackInfoDictRP = new Dictionary<int, AttackArea.AttackInfo>()
        {
            // Åõ
            {1, new AttackArea.AttackInfo(12, transform, AttackArea.AttackType.upper, Vector3.zero) },
            // ÈÅ
            {2, new AttackArea.AttackInfo(15, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ¾îÆÛ
            {3, new AttackArea.AttackInfo(17, transform, AttackArea.AttackType.middle, new Vector3(0, 2000f, 200f)) },
            // ±â»ó ¾îÆÛ
            {4, new AttackArea.AttackInfo(15, transform, AttackArea.AttackType.middle, new Vector3(0,500f,200f)) },
            // ¾îÆÛmk2
            {5, new AttackArea.AttackInfo(15, transform, AttackArea.AttackType.middle, new Vector3(0,500f,200f)) },
            // µÚ¿À¼Õ
            {6, new AttackArea.AttackInfo(19, transform, AttackArea.AttackType.upper, Vector3.zero) }
        };
        attackInfoDictLK = new Dictionary<int, AttackArea.AttackInfo>()
        {
            // Áß´ÜÅ±
            {1, new AttackArea.AttackInfo(16, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ½Ö±â°¢, ¶ç¿ì±â
            {2, new AttackArea.AttackInfo(24, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ¾É¾Æ Â§¹ß
            {3, new AttackArea.AttackInfo(8, transform, AttackArea.AttackType.lower, Vector3.zero) },
            // °æÃµ
            {4, new AttackArea.AttackInfo(18, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ÆÄÄñ¶÷ ¹ÌµéÅ± 1-2Å¸
            {5, new AttackArea.AttackInfo(13, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ´ÏÅ±
            {6, new AttackArea.AttackInfo(16, transform, AttackArea.AttackType.middle, Vector3.zero) }
        };
        attackInfoDictRK = new Dictionary<int, AttackArea.AttackInfo>()
        {
            // ÇÏÀÌÅ±, Ä«¿îÅÍ½Ã ¶ç¿ì±â
            {1, new AttackArea.AttackInfo(11, transform, AttackArea.AttackType.upper, new Vector3(0, 2000f, 500f)) },
            // Â§¹ß
            {2, new AttackArea.AttackInfo(10, transform, AttackArea.AttackType.lower, Vector3.zero) },
            // ÀÌ½½, ³Ñ¾îÁü
            {3, new AttackArea.AttackInfo(17, transform, AttackArea.AttackType.lower, Vector3.zero) },
            // Áß´Ü ¿À¸®¹ß
            {4, new AttackArea.AttackInfo(13, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ±â»ó ¿À¸¥¹ß
            {5, new AttackArea.AttackInfo(10, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // »½¹ß
            {6, new AttackArea.AttackInfo(12, transform, AttackArea.AttackType.middle, Vector3.zero) },
            // ÀÌ½½
            {7, new AttackArea.AttackInfo(10, transform, AttackArea.AttackType.lower, Vector3.zero) },
            // µ¹·ÁÂ÷±â ÇÏÀÌÅ±
            {8, new AttackArea.AttackInfo(10, transform, AttackArea.AttackType.upper, Vector3.zero) }

        };

        PlayerController pc = GetComponent<PlayerController>();
        attackInfoCommandLP = new Dictionary<int, CommandPattern.Action>()
        {
            {2, new CommandPattern.LeftHook(pc)},
            {3, new CommandPattern.LeftUppercut(pc) },
            {4, new CommandPattern.LeftZap(pc)},
            {5, new CommandPattern.LeftBackblow(pc) },
            {6, new CommandPattern.LeftForwardHook(pc) },
            {7, new CommandPattern.LeftElbowHammer(pc) },
            {8, new CommandPattern.LeftQuickHook(pc) },
            {9, new CommandPattern.LeftBodyblow(pc) }
        };
        attackInfoCommandRP = new Dictionary<int, CommandPattern.Action>()
        {
            {1, new CommandPattern.RightTwo(pc) },
            {2, new CommandPattern.RightHook(pc) },
            {3, new CommandPattern.RightUpper(pc) },
            {4, new CommandPattern.RightStandUpper(pc) },
            {5, new CommandPattern.RightUpperTwo(pc) },
            {6, new CommandPattern.RightBackRP(pc) }
        };
        attackInfoCommandLK = new Dictionary<int, CommandPattern.Action>()
        {
            {1, new CommandPattern.LeftMiddleKick(pc) },
            {2, new CommandPattern.LeftDoubleCutKick(pc) },
            {3, new CommandPattern.LeftLowKick(pc) },
            {4, new CommandPattern.LeftKickUppercut(pc) },
            {5, new CommandPattern.LeftMiddleKickTwo(pc) },
            {6, new CommandPattern.LeftKneeKick(pc) }
        };

        attackInfoCommandRK = new Dictionary<int, CommandPattern.Action>()
        {
            {1, new CommandPattern.RightHighKick(pc) },
            {2, new CommandPattern.RightLowKick(pc) },
            {3, new CommandPattern.RightLowKickCrouchRound(pc) },
            {4, new CommandPattern.RightMiddleDuckKick(pc) },
            {5, new CommandPattern.RightStandKick(pc) },
            {6, new CommandPattern.RightMiddleStraightKick(pc) },
            {7, new CommandPattern.RightLowKickRound(pc) },
            {8, new CommandPattern.RightHighKickRound(pc) }
            
        };

        stateBehaviour = animator.GetBehaviour<TestStateBehaviour>();

        commandSystem = FindObjectOfType<CommandSystem>();


        // enemyController
        isHit = false;
        if (transform.name == "1pPlayer")
            opponentAnimator = GameObject.Find("1pPlayer").GetComponent<Animator>();
        else// if (transform.name == "2pPlayer")
            opponentAnimator = GameObject.Find("2pPlayer").GetComponent<Animator>();


        manager = GameObject.Find("Manager");

        //HitEvent.AddListener(() => status.CurrentState = State.Hitted);
        HitEvent.AddListener(() => status.HitState = HitState.Hit);
        HitEvent.AddListener(() => isHit = true);

        effectManager = FindObjectOfType<EffectManager>();

        isGuard = false;

        currentCoroutine = null;
        currentPriority = 0;

        attackAreaManager = GetComponent<AttackAreaManager>();

        replaySystem = FindObjectOfType<ReplaySystem>();
    }

    // Update is called once per frame
    void Update()
    {

    }

    
    private void FixedUpdate()
    {
        transform.LookAt(center);

        if (replaySystem.isReplay)
            return;

        CommandSystem.Command command = null;
        CommandPattern.Action action = null;
        CommandPattern.Action temp1 = null;
        CommandPattern.Action temp2 = null;


        if (transform.name == "1pPlayer")
        {
           command = commandSystem.GetCommand();
        }
        else// if (transform.name == "2pPlayer")
        {
            command = commandSystem.Get2pCommand();
        }

        // Ä¿¸Çµå¿¡ µû¸¥ °¡µå »óÅÂ º¯È­
        guardStateBasedOnCommand((CommandEnum)command.CurrentCommand);

        // »óÅÂ¿Í Ä¿¸Çµå¿¡ µû¸¥ Çàµ¿
        temp1 = actionBasedOnState(command, (CommandEnum)command.CurrentCommand, command.Commands);

        // Æ¯Á¤ Çàµ¿À» ½ÇÇàÇÑ´Ù.
        temp2 = PlayAction(command, command.Commands, command.ActiveCode);

        if (temp1 == null)
            action = temp2;
        else if (temp2 == null)
            action = temp1;
        else
            action = (temp1.priority > temp2.priority) ? temp1 : temp2;

        if (action != null)
        {
            action.excute(transform);
            action.record();
        }
    }

    // Ä¿¸Çµå¸¦ ¾ò´Â ÇÔ¼ö
    public int GetCurrentCommand()
    {
        float horizontal = Input.GetAxisRaw("Horizontal");
        float vertical = Input.GetAxisRaw("Vertical");

        horiVerCommand.TryGetValue(new Vector2(horizontal, vertical), out int command);

        return command;
    }

    // Ä¿¸Çµå°¡ Á÷Àü Ä¿¸Çµå¿Í ¹Ù²î¾ú´ÂÁö È®ÀÎÇÏ´Â ÇÔ¼ö
    public bool IsCommandChange(CommandEnum command)
    {
        if (postCommand != (int)command)
            return true;

        return false;
    }

    // Ä¿¸Çµå°¡ ¹Ù²ï°ÍÀ» queue¿¡ Ãß°¡ÇÏ°í ¸¹ÀÌ ½×ÀÌ¸é ¿À·¡µÈ °ÍºÎÅÍ Á¦°Å °ü¸®
    //void addCommand(int command)
    //{
    //    commands.Enqueue(command);
    //    if (commands.Count > 4)
    //        commands.Dequeue();
    //    postCommand = command;
    //    postCommandTime = currentCommandTime;
    //    currentCommandTime = Time.time;

    //    string s = null;
    //    foreach (int j in commands)
    //        s += j;
    //    //Debug.Log("commands : :" + s);
    //}

    // Ä¿¸Çµå Ã£±â
    bool searchCommands(Queue<int> commands, string command) 
    {
        string s = null;
        foreach (int i in commands)
            s += i;
        bool b = s.Contains(command);
        //Debug.Log(command + "´Â : " + b);

        return b;
    }

    // Ä¿¸Çµå ÃÊ±âÈ­
    void clearCommands()
    {
        commands.Clear();
        postCommand = 0;
    }

    // animator ÃÊ±âÈ­
    void clearAnimator()
    {
        animator.SetBool("Walk", false);
        animator.SetBool("BWalk", false);
        animator.SetBool("Sit", false);
        animator.SetBool("Jump", false);
        animator.SetBool("FrontDash", false);
        animator.SetBool("BackDash", false);
        animator.SetBool("Standing", true);
    }

    

    CommandPattern.Action PlayAction(CommandSystem.Command command, Queue<int>commands, KeyCode code)
    {
        CommandPattern.Action action = null;

        if (code == KeyCode.U)
            action = activeLP(command, commands);
        else if (code == KeyCode.I)
            action = activeRP(command, commands);
        else if (code == KeyCode.J)
            action = activeLK(command, commands);
        else if (code == KeyCode.K)
            action = activeRK(command, commands);

        return action;
    }
    // ¿Þ¼Õ °ø°Ý Å½»ö, ½ÇÇà
    CommandPattern.Action activeLP(CommandSystem.Command command, Queue<int> commands)
    {
        int code = 0;
        CommandPattern.Action action = null;
        // »óÅÂ¿¡ µû¸¥ µ¿ÀÛ
        switch (status.CurrentState)
        {
            case State.Standing:
                if (searchCommands(commands, "656") && command.PostCommand == 6)
                    code = 9;
                else if (command.PostCommand == 6)
                    code = 2;
                else if (command.PostCommand == 3)
                    code = 3;
                else if (command.PostCommand == 4)
                    code = 5;
                else if (command.PostCommand == 9)
                    code = 6;
                else if (command.PostCommand == 7)
                    code = 7;
                else if (command.PostCommand == 8)
                    code = 8;
                else
                    code = 4;
                    //action = new CommandPattern.LeftZap(GetComponent<PlayerController>());
                break;
            case State.Crouching:
                break;
        }
        // attackInfoÀúÀå
        if (code != 0)
        {
            // ¾Ö´Ï¸ÞÀÌ¼Ç ½ÇÇà
            //animator.SetInteger("LPunch", code);
            //animator.SetTrigger("Trigger");

            // ¾Ö´Ï¸Þ´ÏÅÍ º¯¼ö ÃÊ±âÈ­
            //clearAnimator();

            attackInfoDictLP.TryGetValue(code, out attackInfo); // ÀÌ ºÎºÐÀ» attackInfo´ë½Å ¸í·É ÆÐÅÏÀ» ²¨³»µµ·Ï °³¼± > µÑ´Ù ²¨³»¾ßÇÔ, attackInfo¸¦ È÷Æ®¿¡¼­ »ç¿ëÇÔ

            attackInfoCommandLP.TryGetValue(code, out action);

            // °ø°Ý»óÅÂ·Î ÀüÈ¯
            //status.CurrentState = State.Attacking;

            // Çàµ¿Áß Ç¥½Ã
            //animator.SetBool("Acting", true);
        }

        command.Clear();

        return action;
    }

    // ¿À¸¥¼Õ °ø°Ý Å½»ö, ½ÇÇà
    CommandPattern.Action activeRP(CommandSystem.Command command, Queue<int> commands)
    {
        int code = 0;
        CommandPattern.Action action = null;

        // »óÅÂ¿¡ µû¸¥ µ¿ÀÛ
        switch (status.CurrentState)
        {
            case State.Standing:
                if (searchCommands(commands, "523") && command.PostCommand == 3)
                    code = 5;
                else if (command.PostCommand == 6)
                    code = 2;
                else if (command.PostCommand == 3)
                    code = 3;
                else if (command.PostCommand == 4)
                    code = 6;
                else
                    code = 1;
                break;
            case State.Crouching:
                if (command.PostCommand == 5)
                    code = 4;
                break;
        }
        if (code != 0)
        {
            // ¾Ö´Ï¸ÞÀÌ¼Ç ½ÇÇà
            //animator.SetInteger("RPunch", code);
            //animator.SetTrigger("Trigger");

            // ¾Ö´Ï¸Þ´ÏÅÍ º¯¼ö ÃÊ±âÈ­
            //clearAnimator();

            // attackInfoÀúÀå
            attackInfoDictRP.TryGetValue(code, out attackInfo);

            attackInfoCommandRP.TryGetValue(code, out action);

            // °ø°Ý»óÅÂ·Î ÀüÈ¯
            //status.CurrentState = State.Attacking;

            // Çàµ¿Áß Ç¥½Ã
            //animator.SetBool("Acting", true);
        }

        //clearCommands();
        command.Clear();
        return action;

    }

    // ¿Þ¹ß °ø°Ý Å½»ö, ½ÇÇà
    CommandPattern.Action activeLK(CommandSystem.Command command, Queue<int> commands)
    {
        // ¼±ÀÚ¼¼
        int code = 0;
        CommandPattern.Action action = null;

        // »óÅÂ¿¡ µû¸¥ µ¿ÀÛ
        switch (status.CurrentState)
        {
            case State.Standing:
                if (searchCommands(commands, "656") && command.PostCommand == 6)
                    code = 4;
                else if (searchCommands(commands, "523") && command.PostCommand == 3)
                    code = 6;
                else if (command.PostCommand == 9)
                    code = 2;
                else if (command.PostCommand == 3)
                    code = 5;
                else
                    code = 1;
                break;
            case State.Crouching:
                if (command.PostCommand == 2)
                    code = 3;
                break;
        }
        if (code != 0)
        {
            // ¾Ö´Ï¸ÞÀÌ¼Ç ½ÇÇà
            //animator.SetInteger("LKick", code);
            //animator.SetTrigger("Trigger");

            // ¾Ö´Ï¸Þ´ÏÅÍ º¯¼ö ÃÊ±âÈ­
            //clearAnimator();

            // attackInfoÀúÀå
            attackInfoDictLK.TryGetValue(code, out attackInfo);

            attackInfoCommandLK.TryGetValue(code, out action);

            // °ø°Ý»óÅÂ·Î ÀüÈ¯
            //status.CurrentState = State.Attacking;

            // Çàµ¿Áß Ç¥½Ã
            //animator.SetBool("Acting", true);
        }

        //clearCommands();
        command.Clear();
        return action;
    }

    // ¿À¸¥¹ß °ø°Ý Å½»ö, ½ÇÇà
    CommandPattern.Action activeRK(CommandSystem.Command command, Queue<int> commands)
    {
        // ¼±ÀÚ¼¼
        int code = 0;
        CommandPattern.Action action = null;

        // »óÅÂ¿¡ µû¸¥ µ¿ÀÛ
        switch (status.CurrentState)
        {
            case State.Standing:
                if (searchCommands(commands, "656") && command.PostCommand == 6)
                    code = 6;
                else if (searchCommands(commands, "523") && command.PostCommand == 3)
                    code = 7;
                else if (command.PostCommand == 2)
                    code = 2;
                else if (command.PostCommand == 3)
                    code = 4;
                else if (command.PostCommand == 4)
                    code = 8;
                else
                    code = 1;
                break;
            case State.Crouching:
                if (command.PostCommand == 3)
                    code = 3;
                else if (command.PostCommand == 5)
                    code = 5;
                break;
        }
        if (code != 0)
        { 
            // ¾Ö´Ï¸ÞÀÌ¼Ç ½ÇÇà
            //animator.SetInteger("RKick", code);
            //animator.SetTrigger("Trigger");

            // ¾Ö´Ï¸Þ´ÏÅÍ º¯¼ö ÃÊ±âÈ­
            //clearAnimator();

            // attackInfoÀúÀå
            attackInfoDictRK.TryGetValue(code, out attackInfo);

            attackInfoCommandRK.TryGetValue(code, out action);

            // °ø°Ý»óÅÂ·Î ÀüÈ¯
            //status.CurrentState = State.Attacking;

            // Çàµ¿Áß Ç¥½Ã
            //animator.SetBool("Acting", true);
        }

        //clearCommands();
        command.Clear();
        return action;
    }

    // ¿òÁ÷ÀÓ °ü·Ã ÇÔ¼ö
   
    // ´ë±â
    public void idle(int priority, AttackArea.FrameData frameData)
    {
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(idle(frameData));
    }

    IEnumerator idle(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        status.Guard = GuardState.NoGuard;

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        AttackEnd();
    }


    // ÀüÁø
    public void forwardWalk(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if (currentPriority == (int)Colosseum.ActionPriority.Move && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(forwardWalk(frameData));
    }

    IEnumerator forwardWalk(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("Walk", true);
        animator.SetTrigger("Trigger");
        status.Guard = GuardState.NoGuard;

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("Walk", false);
        AttackEnd();
    }

    // ÀüÁø ´ë½¬
    public void forwardDash(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if (currentPriority == (int)Colosseum.ActionPriority.Move && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(forwardDash(frameData));
    }

    IEnumerator forwardDash(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("FrontDash", true);
        animator.SetTrigger("Trigger");
        status.Guard = GuardState.NoGuard;

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("FrontDash", false);
        AttackEnd();
    }

    // µÚ·Î °È±â
    public void backwardWalk(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if ((currentPriority == (int)Colosseum.ActionPriority.Move || currentPriority == (int)Colosseum.ActionPriority.Dash) && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(backwardWalk(frameData));
    }

    IEnumerator backwardWalk(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("BWalk", true);
        animator.SetTrigger("Trigger");
        status.Guard = GuardState.Stand;

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("BWalk", false);
        status.Guard = GuardState.NoGuard;

        AttackEnd();
    }

    // µÚ·Î ´ë½¬
    public void backwardDash(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if (currentPriority == (int)Colosseum.ActionPriority.Move && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(backwardDash(frameData));
    }

    IEnumerator backwardDash(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("BackDash", true);
        animator.SetTrigger("Trigger");

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("BackDash", false);
        AttackEnd();
    }

    // ¾É±â
    public void crouch(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if (currentPriority == (int)Colosseum.ActionPriority.Move && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(crouch(frameData));
    }

    IEnumerator crouch(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("Sit", true);
        animator.SetBool("Standing", false);

        animator.SetTrigger("Trigger");
        status.Guard = GuardState.NoGuard;

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("Sit", false);
        animator.SetBool("Standing", true);
        AttackEnd();
    }

    // ¾É¾Æ¼­ ¾ÕÀ¸·Î °È±â
    public void crouchForwardWalk(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if (currentPriority == (int)Colosseum.ActionPriority.Move && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(crouchForwardWalk(frameData));
    }

    IEnumerator crouchForwardWalk(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("Sit", true);
        animator.SetBool("Standing", false);
        animator.SetBool("Walk", true);
        animator.SetTrigger("Trigger");
        status.Guard = GuardState.NoGuard;

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("Sit", false);
        animator.SetBool("Standing", true);
        animator.SetBool("Walk", false);
        AttackEnd();
    }


    // ¾É¾Æ¼­ µÚ·Î °È±â
    public void crouchBackwardWalk(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if (currentPriority == (int)Colosseum.ActionPriority.Move && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(crouchBackwardWalk(frameData));
    }

    IEnumerator crouchBackwardWalk(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("Sit", true);
        animator.SetBool("Standing", false);
        animator.SetBool("BWalk", true);
        animator.SetTrigger("Trigger");

        status.Guard = GuardState.Crouch;


        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        animator.SetBool("Sit", false);
        animator.SetBool("Standing", true);
        animator.SetBool("BWalk", false);

        status.Guard = GuardState.NoGuard;

        AttackEnd();
    }

    // È÷Æ®
    public void hitHigh(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÌ ÀÖÀ»°æ¿ì Ãë¼ÒÇÏ°í ÇÇ°ÝÇÑ´Ù.
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(hitHigh(frameData));
    }

    IEnumerator hitHigh(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetInteger("HitPos", 1);
        animator.SetBool("Hited", true);

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // Çàµ¿ ³¡
        currentCoroutine = null;
        animator.SetInteger("HitPos", 0);
        animator.SetBool("Hited", false);
        AttackEnd();
    }

    public void hitMiddle(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÌ ÀÖÀ»°æ¿ì Ãë¼ÒÇÏ°í ÇÇ°ÝÇÑ´Ù.
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(hitMiddle(frameData));
    }

    IEnumerator hitMiddle(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetInteger("HitPos", 2);
        animator.SetBool("Hited", true);

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // Çàµ¿ ³¡
        currentCoroutine = null;
        animator.SetInteger("HitPos", 0);
        animator.SetBool("Hited", false);
        AttackEnd();
    }

    public void hitLow(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÌ ÀÖÀ»°æ¿ì Ãë¼ÒÇÏ°í ÇÇ°ÝÇÑ´Ù.
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(hitLow(frameData));
    }

    IEnumerator hitLow(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetInteger("HitPos", 3);
        animator.SetBool("Hited", true);

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // Çàµ¿ ³¡
        currentCoroutine = null;
        animator.SetInteger("HitPos", 0);
        animator.SetBool("Hited", false);
        AttackEnd();
    }

    public void guardHigh(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÌ ÀÖÀ»°æ¿ì Ãë¼ÒÇÏ°í ÇÇ°ÝÇÑ´Ù.
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(guardHigh(frameData));
    }

    IEnumerator guardHigh(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("StandingGuard", true);
        opponentAnimator.SetBool("Blocked", true);

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // Çàµ¿ ³¡
        currentCoroutine = null;
        animator.SetBool("StandingGuard", false);
        AttackEnd();
    }

    public void guardMiddle(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÌ ÀÖÀ»°æ¿ì Ãë¼ÒÇÏ°í ÇÇ°ÝÇÑ´Ù.
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(guardMiddle(frameData));
    }

    IEnumerator guardMiddle(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("StandingGuard", true);
        opponentAnimator.SetBool("Blocked", true);

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // Çàµ¿ ³¡
        currentCoroutine = null;
        animator.SetBool("StandingGuard", false);
        AttackEnd();
    }

    public void guardLow(int priority, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÌ ÀÖÀ»°æ¿ì Ãë¼ÒÇÏ°í ÇÇ°ÝÇÑ´Ù.
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(guardLow(frameData));
    }

    IEnumerator guardLow(AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        clearAnimator();

        animator.SetBool("CrouchGuard", true);
        opponentAnimator.SetBool("Blocked", true);

        // Çàµ¿ ½ÃÀÛ
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // Çàµ¿ ³¡
        currentCoroutine = null;
        animator.SetBool("CrouchGuard", false);
        AttackEnd();
    }


    // ¾Õ´ë½Ã
    void frontDash()
    {
        animator.SetBool("FrontDash", true);
        //animator.SetTrigger("Trigger");

        clearCommands();
    }

    // ¹é´ë½Ã
    void backDash()
    {
        animator.SetBool("BackDash", true);

        clearCommands();
    }

    // ¾É±â
    void crouch()
    {
        animator.SetBool("Sit", true);
        animator.SetBool("Walk", false);
        animator.SetBool("BWalk", false);

        animator.SetBool("Standing", false);
        //status.CurrentState = State.Sitting;
    }

    void Crouching()
    {
        status.CurrentState = State.Crouching;
    }

    // ±âº»»óÅÂ
    void Idle()
    {
        animator.SetBool("Sit", false);
        animator.SetBool("Standing", true);
        //status.CurrentState = State.Standing;
    }

    void Standing()
    {
        status.CurrentState = State.Standing;
    }

    void jump()
    {
        animator.SetBool("Jump", true);
    }

    void EndJump()
    {
        animator.SetBool("Jump", false);
    }

    void DashEnd()
    {
        animator.SetBool("FrontDash", false);
        animator.SetBool("BackDash", false);
        animator.SetBool("Trigger", false);
        clearCommands();
    }

    void StartAttack()
    {
        status.CurrentState = State.Attacking;
    }

    // ÀÌ ÇÔ¼ö°¡ »ç¿ëµÈ ÀÌÈÄ ¼±ÀÔ·ÂÀ» ¹ÞÀ½
    void AttackEnd()
    {
        animator.SetInteger("LPunch", 0);
        animator.SetInteger("RPunch", 0);
        animator.SetInteger("LKick", 0);
        animator.SetInteger("RKick", 0);
        animator.SetBool("Blocked", false);

        //attackInfo.Clear();
        status.CurrentState = State.Standing;
        Idle();

        // Çàµ¿ ³¡ Ç¥½Ã
        animator.SetBool("Acting", false);

        // ¹Ì¿Ï¼º
        //animator.SetInteger("TriggerNum", (int)AnimatorTrigger.StandingIdle);
    }

    void AttackEndCrouch()
    {
        animator.SetInteger("LPunch", 0);
        animator.SetInteger("RPunch", 0);
        animator.SetInteger("LKick", 0);
        animator.SetInteger("RKick", 0);
        animator.SetBool("Blocked", false);

        //attackInfo.Clear();
        status.CurrentState = State.Crouching;
        animator.SetBool("Sit", true);

        // Çàµ¿ ³¡ Ç¥½Ã
        animator.SetBool("Acting", false);

        // ¹Ì¿Ï¼º
        //animator.SetInteger("TriggerNum", (int)AnimatorTrigger.CrouchingIdle);
    } 

    void FootR()
    {

    }
    void FootL()
    {

    }

    void guard(GuardState guard)
    {
        status.Guard = guard;
    }

    CommandPattern.Action actionBasedOnState(CommandSystem.Command command, CommandEnum currentCommand, Queue<int> commands)
    {
        CommandPattern.Action action = null;
        switch (status.CurrentState)
        {
            case State.Standing:
                switch (currentCommand)
                {
                    case CommandEnum.E:
                        action = new CommandPattern.ForwardWalk(GetComponent<PlayerController>());
                        if (searchCommands(commands, "656") && animator.GetBool("FrontDash") == false && Time.time - command.PostCommandTime < 0.15f)
                            action = new CommandPattern.ForwardDash(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.W:
                        action = new CommandPattern.BackwardWalk(GetComponent<PlayerController>());
                        if (searchCommands(commands, "454") && animator.GetBool("BackDash") == false && Time.time - command.PostCommand < 0.15f)
                            action = new CommandPattern.BackwardDash(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.Neutral:
                        //stateBehaviour.WalkStop(animator);
                        //Idle();
                            action = new CommandPattern.Idle(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.SW:
                    case CommandEnum.S:
                    case CommandEnum.SE:
                        action = new CommandPattern.Crouch(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.NW:
                    case CommandEnum.N:
                    case CommandEnum.NE:
                        //jump();
                        break;
                }
                break;
            case State.Crouching:
                switch (currentCommand)
                {
                    case CommandEnum.SW:
                        action = new CommandPattern.CrouchBackwardWalk(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.SE:
                        action = new CommandPattern.CrouchForwardWalk(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.S:
                        action = new CommandPattern.Crouch(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.Neutral:
                        //Idle();
                        action = new CommandPattern.Idle(GetComponent<PlayerController>());
                        break;
                }
                break;
            case State.Attacking:
                switch (currentCommand)
                {
                    case CommandEnum.S:
                        action = new CommandPattern.Crouch(GetComponent<PlayerController>());
                        break;
                    case CommandEnum.Neutral:
                        //Idle();
                        break;
                }
                break;
        }
        return action;
    }

    void guardStateBasedOnCommand(CommandEnum command)
    {
        if (command == CommandEnum.W)
            guard(GuardState.Stand);
        else if (command == CommandEnum.SW)
            guard(GuardState.Crouch);
        else
            guard(GuardState.NoGuard);
    }

    // EnemyController¿¡ ÀÖ´ø°Í ¿Å±è
    // ÇÇ°Ý ´çÇÔ
    public void Hit(AttackArea.AttackInfo attackInfo)
    {
        CommandPattern.Action action = null;
        //Debug.Log("1");
        if (isHit)
            return;
        //Debug.Log("2");
        if (isGuard)
            return;
        //Debug.Log("3");
        // °¡µå È®ÀÎ
        switch (attackInfo.attackType)
        {
            case AttackArea.AttackType.upper:
                if (status.CurrentState == State.Crouching)
                    return;
                if (status.Guard == GuardState.Stand)
                {
                    //standingGuard(attackInfo);
                    action = new CommandPattern.GuardHigh(GetComponent<PlayerController>());
                    effectManager.PlayGuardEffect(attackInfo.hitPos);
                    isGuard = true;

                    action.excute(transform);
                    return;
                }
                break;
            case AttackArea.AttackType.middle:
                if (status.Guard == GuardState.Stand)
                {
                    //standingGuard(attackInfo);
                    action = new CommandPattern.GuardMiddle(GetComponent<PlayerController>());
                    effectManager.PlayGuardEffect(attackInfo.hitPos);
                    isGuard = true;

                    action.excute(transform);
                    return;
                }
                break;
            case AttackArea.AttackType.lower:
                if (status.Guard == GuardState.Crouch)
                {
                    //crouchGuard(attackInfo);
                    action = new CommandPattern.GuardLow(GetComponent<PlayerController>());
                    effectManager.PlayGuardEffect(attackInfo.hitPos);

                    action.excute(transform);
                    return;
                }
                break;
        }
        //Debug.Log("4");
        // °ø°Ý¿¡ µû¸¥ ÇÇ°Ý ¸ð¼Ç
        switch (attackInfo.attackType)
        {
            case AttackArea.AttackType.upper:
                //animator.SetInteger("HitPos", 1);
                effectManager.PlayHitEffect(attackInfo.hitPos);
                action = new CommandPattern.HitHigh(GetComponent<PlayerController>());
                break;
            case AttackArea.AttackType.middle:
                //animator.SetInteger("HitPos", 2);
                effectManager.PlayHitEffect(attackInfo.hitPos);
                action = new CommandPattern.HitMiddle(GetComponent<PlayerController>());
                break;
            case AttackArea.AttackType.lower:
                //animator.SetInteger("HitPos", 3);
                effectManager.PlayHitEffect(attackInfo.hitPos);
                action = new CommandPattern.HitLow(GetComponent<PlayerController>());
                break;
        }

        //Debug.Log("Hited");
        //animator.SetBool("Hited", true);
        if (action != null)
            action.excute();

        HitEvent.Invoke();
        status.Damaged(attackInfo.attackPower);
        //Debug.Log("power : " + attackInfo.attackPower);
        GetComponent<Rigidbody>().velocity = Vector3.zero;
        GetComponent<Rigidbody>().AddForce(attackInfo.force);

        manager.SendMessage("UIUpdate");
    }

    void EndHit()
    {
        isHit = false;
        animator.SetBool("Hited", false);

        status.CurrentState = State.Standing;
    }

    void EndGuard()
    {
        animator.SetBool("StandingGuard", false);
        animator.SetBool("CrouchGuard", false);

        isGuard = false;

        status.CurrentState = State.Standing;
    }

    void standingGuard(AttackArea.AttackInfo attackInfo)
    {
        animator.SetBool("StandingGuard", true);

        GetComponent<Rigidbody>().AddForce(attackInfo.force);

        opponentAnimator.SetBool("Blocked", true);

        manager.SendMessage("UIUpdate");
    }

    void crouchGuard(AttackArea.AttackInfo attackInfo)
    {
        animator.SetBool("CrouchGuard", true);

        GetComponent<Rigidbody>().AddForce(attackInfo.force);

        opponentAnimator.SetBool("Blocked", true);

        manager.SendMessage("UIUpdate");
    }

    // Ä¿¸Çµå ÆÐÅÏ »ç¿ëÇØ¼­ ÄÚ·çÆ¾À¸·Î µ¹¸®°í 
    // À§ÀÇ ¾×Æ¼ºê ÄÚ·çÆ¾Àº Áß°£¿¡ ¸ØÃß¸é ¾ÈµÇ´Ï±î ¸ØÃß´Â°Å ¸·°í ¿¬°è°ø°ÝÀº ¾ÆÁ÷ ¸ð¸£°ÚÀ½
    // ¸ØÃß´Â°Å ¸·À» ¶§ È÷Æ®·Î ÀÎÇÑ »óÈ²À» ¿°µÎÇØ µÖ¾ßÇÔ, Ä¿¸Çµå ÆÐÅÏ ½ÇÇà µÉ¶§ ÀúÀåÇØ³õ°í ¸®ÇÃ·¹ÀÌ·Î È°¿ë
    // Ä¿¸Çµå ÆÐÅÏÀº active rp lp rk lk¿¡¼­ ¹ñ¾î³»°Ô ÇÏ°í ±×°ÍÀ» ÃÖÁ¾ ºñ±³¸¦ ÅëÇØ¼­ ÇÏ³ª¾¿ ½ÇÇà ±×¸®°í ½ÇÇàÇÑ °ÍÀ» ÀúÀå
    public void activeCoroutineLP(int actionCode, int priority, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if ((currentPriority == (int)Colosseum.ActionPriority.Move || currentPriority == (int)Colosseum.ActionPriority.Dash) && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(ActiveActionLP(actionCode, attackInfo, frameData));
    }

    IEnumerator ActiveActionLP(int actionCode, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        animator.SetInteger("LPunch", actionCode);
        animator.SetTrigger("Trigger");
        animator.SetBool("Acting", true);

        this.attackInfo = attackInfo;
        status.Guard = GuardState.NoGuard;

        // °ø°Ý ½ÃÀÛ
        while (frameData.startHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        attackAreaManager.SendMessage("StartAttackHit");
        // whileÀ» ÅëÇØ¼­ nÇÁ·¹ÀÓ½ÃÀÛ nÇÁ·¹ÀÓ ³¡À» ÁöÁ¤
        // È÷Æ® ÆÇÁ¤ ½ÃÀÛ
        while (frameData.endHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        attackAreaManager.SendMessage("EndAttackHit");
        // È÷Æ® ÆÇÁ¤ ³¡
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        AttackEnd();
    }

    public void activeCoroutineRP(int actionCode, int priority, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if ((currentPriority == (int)Colosseum.ActionPriority.Move || currentPriority == (int)Colosseum.ActionPriority.Dash) && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(ActiveActionRP(actionCode, attackInfo, frameData));
    }

    IEnumerator ActiveActionRP(int actionCode, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        animator.SetInteger("RPunch", actionCode);
        animator.SetTrigger("Trigger");
        animator.SetBool("Acting", true);

        this.attackInfo = attackInfo;
        status.Guard = GuardState.NoGuard;


        // °ø°Ý ½ÃÀÛ
        while (frameData.startHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        attackAreaManager.SendMessage("StartAttackHit");
        // whileÀ» ÅëÇØ¼­ nÇÁ·¹ÀÓ½ÃÀÛ nÇÁ·¹ÀÓ ³¡À» ÁöÁ¤
        // È÷Æ® ÆÇÁ¤ ½ÃÀÛ
        while (frameData.endHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // È÷Æ® ÆÇÁ¤ ³¡
        attackAreaManager.SendMessage("EndAttackHit");
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        AttackEnd();
    }

    public void activeCoroutineLK(int actionCode, int priority, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if ((currentPriority == (int)Colosseum.ActionPriority.Move || currentPriority == (int)Colosseum.ActionPriority.Dash) && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(ActiveActionLK(actionCode, attackInfo, frameData));
    }

    IEnumerator ActiveActionLK(int actionCode, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        animator.SetInteger("LKick", actionCode);
        animator.SetTrigger("Trigger");
        animator.SetBool("Acting", true);

        this.attackInfo = attackInfo;
        status.Guard = GuardState.NoGuard;


        // °ø°Ý ½ÃÀÛ
        while (frameData.startHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // whileÀ» ÅëÇØ¼­ nÇÁ·¹ÀÓ½ÃÀÛ nÇÁ·¹ÀÓ ³¡À» ÁöÁ¤
        // È÷Æ® ÆÇÁ¤ ½ÃÀÛ
        attackAreaManager.SendMessage("StartAttackHit");
        while (frameData.endHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // È÷Æ® ÆÇÁ¤ ³¡
        attackAreaManager.SendMessage("EndAttackHit");
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        AttackEnd();
    }

    public void activeCoroutineRK(int actionCode, int priority, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        // ÇöÀç ½ÇÇàÁßÀÎ Çàµ¿ÀÇ ¿ì¼±¼øÀ§°¡ ÀÌµ¿ÀÎ °æ¿ì Áß´ÜÇÏ°í ½ÇÇà
        if ((currentPriority == (int)Colosseum.ActionPriority.Move || currentPriority == (int)Colosseum.ActionPriority.Dash) && currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
            currentCoroutine = null;
        }
        // ÀÔ·Â ¹ÞÀ» ¼ö ÀÖ´Â »óÈ²ÀÏ °æ¿ì ¾î¶² Çàµ¿ÀÎÁö È®ÀÎÇÑ´Ù(¿¬°è °ø°Ý ÁØºñ)
        // ¾Æ´Ò °æ¿ì ±âÁ¸ Çàµ¿À» Áö¼ÓÇÑ´Ù.
        else if (currentCoroutine != null)
            return;

        // ½ÇÇà
        currentPriority = priority;
        currentCoroutine = StartCoroutine(ActiveActionRK(actionCode, attackInfo, frameData));
    }

    IEnumerator ActiveActionRK(int actionCode, AttackArea.AttackInfo attackInfo, AttackArea.FrameData frameData)
    {
        int currentFrame = 0;
        animator.SetInteger("RKick", actionCode);
        animator.SetTrigger("Trigger");
        animator.SetBool("Acting", true);

        this.attackInfo = attackInfo;
        status.Guard = GuardState.NoGuard;


        // °ø°Ý ½ÃÀÛ
        while (frameData.startHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        attackAreaManager.SendMessage("StartAttackHit");
        // whileÀ» ÅëÇØ¼­ nÇÁ·¹ÀÓ½ÃÀÛ nÇÁ·¹ÀÓ ³¡À» ÁöÁ¤
        // È÷Æ® ÆÇÁ¤ ½ÃÀÛ
        while (frameData.endHitFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // È÷Æ® ÆÇÁ¤ ³¡
        attackAreaManager.SendMessage("EndAttackHit");
        while (frameData.actionFrame > currentFrame)
        {
            currentFrame++;
            yield return new WaitForFixedUpdate();
        }
        // °ø°Ý ³¡
        currentCoroutine = null;
        AttackEnd();
    }
}